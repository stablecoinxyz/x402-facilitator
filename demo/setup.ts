import { createWalletClient, http, parseEther, formatEther } from 'viem';
import { base } from 'viem/chains';
import { loadOrGenerateKey, getAccount, publicClient, DATA_DIR } from './utils';
import fs from 'fs';
import path from 'path';

// Base Mainnet SBC Token Address (18 decimals)
const SBC_ADDRESS = '0xfdcC3dd6671eaB0709A4C0f3F53De9a333d80798';
const SBC_DECIMALS = 18;

// Minimal ERC20 ABI for what we need (balanceOf, approve)
const ERC20_ABI = [
  {
    constant: false,
    inputs: [
      { name: 'spender', type: 'address' },
      { name: 'amount', type: 'uint256' }
    ],
    name: 'approve',
    outputs: [{ name: '', type: 'bool' }],
    payable: false,
    stateMutability: 'nonpayable',
    type: 'function'
  },
  {
    constant: true,
    inputs: [{ name: '', type: 'address' }],
    name: 'balanceOf',
    outputs: [{ name: '', type: 'uint256' }],
    payable: false,
    stateMutability: 'view',
    type: 'function'
  }
] as const;

async function setup() {
  console.log('üöÄ Setting up x402 Facilitator Demo (Base Mainnet)');
  console.log('===================================================');
  console.log(`üìÇ Data directory: ${DATA_DIR}`);

  // 1. Load/Generate Wallets
  const facilitator = getAccount('facilitator');
  const merchant = getAccount('merchant');
  const client = getAccount('client');

  console.log(`\nüîë Wallets:`);
  console.log(`   Facilitator: ${facilitator.address}`);
  console.log(`   Merchant:    ${merchant.address}`);
  console.log(`   Client:      ${client.address} (PAYER)`);

  // 2. Check ETH Balances (Client AND Facilitator)
  // Client needs ETH to sign the 'approve' transaction during setup.
  // Facilitator needs ETH to sign the 'transferFrom' transaction during settlement.

  const clientBalance = await publicClient.getBalance({ address: client.address });
  const facilitatorBalance = await publicClient.getBalance({ address: facilitator.address });

  const clientEth = formatEther(clientBalance);
  const facilitatorEth = formatEther(facilitatorBalance);

  console.log(`\nüí∞ ETH Balances:`);
  console.log(`   Client:      ${clientEth} ETH`);
  console.log(`   Facilitator: ${facilitatorEth} ETH`);

  let needsFunding = false;

  if (clientBalance < parseEther('0.002')) {
    console.log('\n‚ö†Ô∏è  CLIENT NEEDS ETH');
    console.log(`   Address: ${client.address}`);
    needsFunding = true;
  }

  if (facilitatorBalance < parseEther('0.002')) {
    console.log('\n‚ö†Ô∏è  FACILITATOR NEEDS ETH');
    console.log(`   Address: ${facilitator.address}`);
    needsFunding = true;
  }

  if (needsFunding) {
    console.log('\n   Please fund the wallets with Base ETH for gas.');
    console.log('   Send ETH on Base to the addresses above.');
    console.log('\n   Once funded, run "npm run setup" again.');
    process.exit(1);
  }

  // 3. Setup Wallet Client for transactions
  const clientWallet = createWalletClient({
    account: client,
    chain: base,
    transport: http()
  });

  // 4. Check Client SBC Balance
  console.log('\nüîç Checking SBC Token Balance...');
  const sbcBalance = await publicClient.readContract({
    address: SBC_ADDRESS,
    abi: ERC20_ABI,
    functionName: 'balanceOf',
    args: [client.address]
  });

  const sbcFormatted = Number(sbcBalance) / Math.pow(10, SBC_DECIMALS);
  console.log(`   SBC Balance: ${sbcFormatted} SBC (${sbcBalance.toString()} units)`);

  if (sbcFormatted < 0.01) {
    console.log('\n‚ö†Ô∏è  INSUFFICIENT SBC TOKENS');
    console.log('   Please fund the Client wallet with SBC tokens on Base.');
    console.log(`   Address: ${client.address}`);
    console.log(`   Token Contract: ${SBC_ADDRESS}`);
    console.log('\n   Once funded, run "npm run setup" again.');
    process.exit(1);
  }

  // 5. Approve Facilitator
  console.log('\nü§ù Approving Facilitator as Spender...');
  const approvalAmount = BigInt(100) * BigInt(10) ** BigInt(SBC_DECIMALS);

  const approveHash = await clientWallet.writeContract({
      address: SBC_ADDRESS,
      abi: ERC20_ABI,
      functionName: 'approve',
      args: [facilitator.address, approvalAmount]
  });

  console.log(`   Tx Hash: ${approveHash}`);
  await publicClient.waitForTransactionReceipt({ hash: approveHash });
  console.log('   ‚úÖ Facilitator approved to spend SBC');

  // 6. Generate .env file
  console.log('\nüìù Generating .env file...');

  const envContent = `
# Generated by demo/setup.ts
FACILITATOR_PORT=3001

# Base Configuration (Mainnet)
BASE_RPC_URL=https://mainnet.base.org
BASE_CHAIN_ID=8453
BASE_SBC_TOKEN_ADDRESS=${SBC_ADDRESS}
BASE_SBC_DECIMALS=${SBC_DECIMALS}
BASE_FACILITATOR_PRIVATE_KEY=${loadOrGenerateKey('facilitator')}
BASE_FACILITATOR_ADDRESS=${facilitator.address}

# Real Settlement Enabled (Required for permit + transferFrom to work)
ENABLE_REAL_SETTLEMENT=true

# Solana Config (Optional)
SOLANA_RPC_URL=https://api.mainnet-beta.solana.com
`.trim();

  fs.writeFileSync(path.join(process.cwd(), '.env'), envContent);
  console.log('   ‚úÖ .env file created');

  console.log('\nüéâ Setup Complete!');
  console.log('   1. Start the server: npm run dev');
  console.log('   2. Run the demo client: npm run demo');
}

setup().catch(err => {
    console.error('‚ùå Setup failed:', err);
    process.exit(1);
});
