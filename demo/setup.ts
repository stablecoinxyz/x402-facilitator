import { createWalletClient, http, parseEther, formatEther } from 'viem';
import { loadOrGenerateKey, getAccount, getPublicClient, getNetwork, getViemChain, DATA_DIR } from './utils';
import fs from 'fs';
import path from 'path';

// Minimal ERC20 ABI for what we need (balanceOf, approve)
const ERC20_ABI = [
  {
    constant: false,
    inputs: [
      { name: 'spender', type: 'address' },
      { name: 'amount', type: 'uint256' }
    ],
    name: 'approve',
    outputs: [{ name: '', type: 'bool' }],
    payable: false,
    stateMutability: 'nonpayable',
    type: 'function'
  },
  {
    constant: true,
    inputs: [{ name: '', type: 'address' }],
    name: 'balanceOf',
    outputs: [{ name: '', type: 'uint256' }],
    payable: false,
    stateMutability: 'view',
    type: 'function'
  }
] as const;

async function setup() {
  const network = getNetwork();
  const publicClient = getPublicClient(network);
  const chain = getViemChain(network);

  console.log(`ğŸš€ Setting up x402 Facilitator Demo (${network.name})`);
  console.log('===================================================');
  console.log(`ğŸ“‚ Data directory: ${DATA_DIR}`);
  console.log(`ğŸŒ Network: ${network.name} (chainId: ${network.chainId})`);
  console.log(`ğŸ”— RPC: ${network.rpcUrl}`);
  console.log(`ğŸª™ SBC Token: ${network.sbcAddress} (${network.sbcDecimals} decimals)`);

  // 1. Load/Generate Wallets
  const facilitator = getAccount('facilitator');
  const merchant = getAccount('merchant');
  const client = getAccount('client');

  console.log(`\nğŸ”‘ Wallets:`);
  console.log(`   Facilitator: ${facilitator.address}`);
  console.log(`   Merchant:    ${merchant.address}`);
  console.log(`   Client:      ${client.address} (PAYER)`);

  // 2. Check ETH Balances (Client AND Facilitator)
  const clientBalance = await publicClient.getBalance({ address: client.address });
  const facilitatorBalance = await publicClient.getBalance({ address: facilitator.address });

  const clientEth = formatEther(clientBalance);
  const facilitatorEth = formatEther(facilitatorBalance);

  console.log(`\nğŸ’° ETH Balances:`);
  console.log(`   Client:      ${clientEth} ETH`);
  console.log(`   Facilitator: ${facilitatorEth} ETH`);

  let needsFunding = false;

  if (clientBalance < parseEther('0.002')) {
    console.log('\nâš ï¸  CLIENT NEEDS ETH');
    console.log(`   Address: ${client.address}`);
    needsFunding = true;
  }

  if (facilitatorBalance < parseEther('0.002')) {
    console.log('\nâš ï¸  FACILITATOR NEEDS ETH');
    console.log(`   Address: ${facilitator.address}`);
    needsFunding = true;
  }

  if (needsFunding) {
    console.log(`\n   Please fund the wallets with ETH on ${network.name} for gas.`);
    console.log('   Send ETH to the addresses above.');
    if (network.networkId === 'base-sepolia') {
      console.log('   Faucet: https://www.alchemy.com/faucets/base-sepolia');
    }
    console.log('\n   Once funded, run "npm run setup" again.');
    process.exit(1);
  }

  // 3. Setup Wallet Client for transactions
  const clientWallet = createWalletClient({
    account: client,
    chain,
    transport: http(network.rpcUrl)
  });

  // 4. Check Client SBC Balance
  console.log('\nğŸ” Checking SBC Token Balance...');
  const sbcBalance = await publicClient.readContract({
    address: network.sbcAddress,
    abi: ERC20_ABI,
    functionName: 'balanceOf',
    args: [client.address]
  });

  const sbcFormatted = Number(sbcBalance) / Math.pow(10, network.sbcDecimals);
  console.log(`   SBC Balance: ${sbcFormatted} SBC (${sbcBalance.toString()} units)`);

  if (sbcFormatted < 0.01) {
    console.log('\nâš ï¸  INSUFFICIENT SBC TOKENS');
    console.log(`   Please fund the Client wallet with SBC tokens on ${network.name}.`);
    console.log(`   Address: ${client.address}`);
    console.log(`   Token Contract: ${network.sbcAddress}`);
    console.log('\n   Once funded, run "npm run setup" again.');
    process.exit(1);
  }

  // 5. Approve Facilitator
  console.log('\nğŸ¤ Approving Facilitator as Spender...');
  const approvalAmount = BigInt(100) * BigInt(10) ** BigInt(network.sbcDecimals);

  const approveHash = await clientWallet.writeContract({
      address: network.sbcAddress,
      abi: ERC20_ABI,
      functionName: 'approve',
      args: [facilitator.address, approvalAmount]
  });

  console.log(`   Tx Hash: ${approveHash}`);
  if (network.explorerTxUrl) {
    console.log(`   Explorer: ${network.explorerTxUrl}${approveHash}`);
  }
  await publicClient.waitForTransactionReceipt({ hash: approveHash });
  console.log('   âœ… Facilitator approved to spend SBC');

  // 6. Generate .env file â€” map network to the right env var prefix
  console.log('\nğŸ“ Generating .env file...');

  const envPrefix = network.networkId.startsWith('radius') ? 'RADIUS' : 'BASE';

  const envContent = `
# Generated by demo/setup.ts (network: ${network.networkId})
FACILITATOR_PORT=3001

# ${network.name} Configuration
${envPrefix}_RPC_URL=${network.rpcUrl}
${envPrefix}_CHAIN_ID=${network.chainId}
${envPrefix}_SBC_TOKEN_ADDRESS=${network.sbcAddress}
${envPrefix}_SBC_DECIMALS=${network.sbcDecimals}
${envPrefix}_FACILITATOR_PRIVATE_KEY=${loadOrGenerateKey('facilitator')}
${envPrefix}_FACILITATOR_ADDRESS=${facilitator.address}

# Real Settlement Enabled (Required for permit + transferFrom to work)
ENABLE_REAL_SETTLEMENT=true

# Solana Config (Optional)
SOLANA_RPC_URL=https://api.mainnet-beta.solana.com
`.trim();

  fs.writeFileSync(path.join(process.cwd(), '.env'), envContent);
  console.log('   âœ… .env file created');

  console.log('\nğŸ‰ Setup Complete!');
  console.log('   1. Start the server: npm run dev');
  console.log(`   2. Run the demo client: npm run demo -- --network ${network.networkId}`);
}

setup().catch(err => {
    console.error('âŒ Setup failed:', err);
    process.exit(1);
});
